******************************************************************************************************************
## Run instructions:
1. run `python initialize.py /path/to/project` for static analysis part (Requires clang installed)
(eg: `python initialize.py testsuite/extern` or `python initialize.py projects/libpng`)
This command
- builds the project
- gets all static information corresponding to C/C++ files in folder `outputs/projectname/`
- needs to be run only once for any project
2. create runinfo.json in format specified in `sample_runs.json` containing info regarding the test executables, comment analysis and version control stats.
3. run `python examine.py /path/to/runinfo.json` for the analysis (Requires PIN tool)
(eg: `python examine.py testsuite/extern/runs_extern.json` or `python examine.py sample_runs.json`)
This command
- takes the testsuite executables with the inputs you want to examine
- links up all the static source code and object code information from the files contained
- runs the executables with given inputs and flags and trace the runtime
- collects all dynamic information for all the runs in outputs/projectname/exe_exename/ for each executable
- collects comment information in outputs/projectname/final_comments.xml
******************************************************************************************************************

******************************************************************************************************************
## PROJECT FORMAT

Our tool expects projects to:
	- be C/C++ based
	- use makefiles for project build
	- use CMake as the makefile generator
	- support verbose makes and debug build
	- work on Unix-based OSes
	- contain testsuite we may use for runtime tracing


### Sidenote: What is CMake?
- CMake is a makefile generator. It takes care of your project build process.
- Basically, it will generate makefiles tailored to the system on which the project is being built.
- So, it will take care of the differences based on the OS. eg: in Windows, .so files are called .dll, options are passed like /a intead of -a
- It will do other things like detect the C++ compiler you are saying eg: maybe the system has clang C compiler instead of gcc


### CMAKE BUILD PROCESS

Basic idea of the CMake build process:
1. You have the source C code
2. You convert each C file to a .o file using `gcc -c`. This .o is called a relocatable object file
3. You can combine a few related object files into two forms of collections: archives(.a) and shared object/shared library (.so)
4. Archives and Shared Objects are basically the .o files written one after the other, combined into one file
5. To create an executable, you take a bunch of .o files (.a and .so are also collections of .o files only as mentioned earlier), and you link them together. This is done using by passing it the object files to gcc.
6. The difference between .a and .so files is that: 
	- .a gets linked statically ie its code gets written into the final executable directly
	- .so gets linked dynamically ie its code is loaded at runtime when executable calls functions from it. Its code is also shared as in multiple executables will use the same copy of the .so
7. Usually, large projects have this structure:
	- take lots and lots of small .c files
	- convert each to .o
	- join all of them into a very large .so file
	- create small executables from some file that contains a main() function
	- that executable links against the large .so, calls functions from that
******************************************************************************************************************


******************************************************************************************************************
## Tool Workflow:

### Imp note on file extensions:
- all extensions are declared in initialize.py/examine.py
- new files containing information about the .c or corresponding .o are generated by parsers in parsers/ folder
- the extensions for the files to generate are passed to the parsers by initialize.py and examine.py
- this approach allows us to modify filenames by making changes only in initialize/examine

1. initialize.py: takes the project as input
	- init(): 
		- uses CMake to generate makefiles
		- then builds the project by running `make`
		- the make command is run in verbose mode, and the commands run by make are collected in make_log.txt
		- creates the folder outputs/projectname
		- moves make_log.txt to this folder
	- generate_static_info():
		- runs parsers/project_parser.py on make_log.txt
		- that generate a dependencies.p (pickle file) that contains file dependency relationships (explained later)
		- for each C/C++ file, say projects/exp/src/A.c, in dependencies.p, we know that a .o will be generated corr. to it. We
			- run clang on A.c to generate A.ast
			- run clangtools
				- parsers/ast2xml: generates A_clang.xml & A.calls.temp from A.ast
				- parsers/calls: generates A.calls.tokens from A.calls.temp
				- parsers/funcs.py: generates A.funcargs from A_clang.xml
			- copy these 3 files to the folder location: outputs/exp/src/A.c/
			- run parsers/dwxml.py on A.o to generate A_dd.xml in outputs/exp/src/
			- run parsers/ddx.py with OFFSET flag
				- that combines only the local variables present in A.c from A_clang.xml and A_dd.xml
				- creates A_comb.xml and A.offset in outputs/exp/src/A.c/
			Note: All these files' purposes are explained in File Introductions section

2. parsers:
	A. project_parser.py:
		- takes each line in make_log.txt
		- takes out the relevant gcc command
		- keeps track of all cd commands to figure out absolute paths of each file
		- figures out which .c files are used to generate which .o
		- figures out which .o files are combined to generate which .a/.so
		- pickles the collected information into dependencies.p (explained later)
	B. ast2xml.cc:
		- takes in A.ast (clang generated syntax tree file)
		- extracts the relevant static information contained in it in XML format into A_clang.xml
		- collects the funtion call node locations into A.calls.temp
	C. calls.cc:
		- takes in A.calls.temp
		- adds corresponding the source call exressions to each call node
		- generates A.calls.tokens
	D. funcs.py:
		- takes in A_clang.xml
		- generates A.funcargs containing function signatures for all functions declared in the TU
	E. dwxml.py: takes the debug info in the .o, converts information into XML (depends on [pyelftools](https://github.com/eliben/pyelftools))
	F. ddx.py:
		- takes in A_dd.xml and A_clang.xml
		- takes in an argument (OFFSET or ADDRESS)
		- if argument is OFFSET, it links all the local variables
		- if argument is ADDRESS, it links all the static storage variables
		- generates corresponding A.offset or A.address based on the flag
		- generates A_comb.xml with offsets/addresses patched in
		- can also link multiple external declarations across source files to the one true definition
	G. uniquify.py:
		- performs header deduplication: a header can be included in multiple files. the multiple copies of nodes from such headers are uniquified.
		- creates final_idmap.p
		- corrects the files containing node ids of the deleted duplicate nodes using final_idmap

3. examine.py: takes the runs_info.json
	- creates the folder outputs/projectname/exe_exename
	- generate_static_info():
		- gets the list of all .c files that create the excutable
		- calls combine_all_clang
	- combine_all_clang():
		- for every image contained in the executable (main executable image and all the .so's basically)
			- creates the folder outputs/projectname/exe_exename/imagename
			- runs dwxml.py on image to generate image_dd.xml
			- for every .c file that makes up that particular image
				- concats the .calls, .funcargs and .offset into final.calls, final.funcargs and final.offset respectively
				- ddx.UpdateCtree(): combines address info from image_dd.xml into the clang xml
			- concats these "updated" \_clang.xmls into image_comb.xml
			- ddx.generate_var(): creates image.address (explained later)
			- all `image*` files are kept in outputs/projectname/exe_exename/imagename
			- copies all the image.address files to outputs/projectname/exe_exename/
		- runs ddx.patch_external_def_ids(): links all external declarations across all source files to the one true definition node
		- runs uniquify in this statically interlinked executable xml:
			- performs header deduplication: a header can be included in multiple files. the multiple copies of nodes from such headers are uniquified
			- creates final_idmap.p (explained later)
		- the final uniquified, interlinked XML is written as final_static.xml
	- so now, we have the outputs/projectname/exe_exename/ containing all the static information:
		- image.address for all images creating the executable
		- final_clang.xml
		- final.calls, final.funcargs, final.offset
	- generate_dynamic_info(): runs pin.sh

4. pin.sh:
	- copies executable into PIN/Work
	- copies the static information collected to PIN/Work/statinfo
	- runs `make executable.dump`, which runs memtracker on executable to generate executable.dump
	- runs pass2.py on executable.dump to generate final_dynamic.xml
	- copies executable.dump and final_dynamic.xml to /projectname/exe_exename/
	
5. memtracker.cpp: * the instrumentation routine name is noted in square brackets [] *
	- Initialization: init()
		- load final.calls, final.funcargs, final.offset into funcCallMap, funcInfoMap, funcLocalMap repectively
		- initializes the function stack record which keeps track of the thread-wise function stack
		- initializes the RBP stack record which keeps track of the thread-wise RBP stack
	- Image Level Instrumentation: ImageLoad()
		- loads image.address information into globalMap
		- adds image load address to the values in image.addres to get runtime address of variables
		- traces heap memory allocations and reallocation [addHeapRequest() & addHeapMap()]
		- traces heap memory deallocations [remHeapMap()]
	- Routine Level Instrumentation: Routine()
		- gets source line information for each function
		- instruments before each function invocation to note the stack change [invP()]
		- instruments before each call to POSIX lock acquisition routines to note the LOCK event [lock_func_bf()]
		- instruments before each call to POSIX lock release routines to note the UNLOCK event [unlock_func()]
	- Instruction Level Instrumentation:
		- gets source line information for each intruction
		- for each intruction whose source is known (basically this excludes the standard header functions)
			- if it is a call instruction [callP()] add instrumentation to
				- collect the runtime value of passed arguments
				- note the CALL event noting down CALLER, current THREAD etc.
				- update the function stack record
			- if it is a return instruction [retP()] add instrumentation to
				- collect the runtime return value of function
				- note the RETURN event noting down current THREAD etc.
				- update the function stack record
			- if it updates RBP (call and return events basically) [updateRBP()], update the RBP stack record
			- if it is a memory access instruction [dataman()] add instrumentation to
				- find if it is a auto or static storage variable
				- locate the variable within the funcLocalMap or globalMap depending on the case
				- note down the locks held by thread while accessing the variable
				- generate the corresponding READ or WRITE event
			- if it is updation of a pointer [ptrWrite()] add instrumentation to
				- find the new location where the pointer points
				- add all the information collected by dataman
				- generate the corresponding POINTERWRITE event

6. pass2.py:
	- converts executable.dump to XML format
	- accumulates all local variable accesses (read/write) in one function into one XML entry
	- more specifically, if the event sequence is: call A(), read X, read Y, read X, write Y, call B(), return from B(), read X, return from A()
	- ^ this will change into: <call A>, <localaccess X: read 2>, <localaccess Y: read 1 write 1>, <call B>, <ret B> <localaccess X: read 1>, <ret A>
	- ie accesses are accumulated in between special events like function call, return or lock acquisition
	- the access order for static storage variables in preserved

Imp note on tool workflow choices:
- initialize does everything needed to be done for the project to make the further executable analysis faster
- so, all local variable offsets are extracted during initialize stage as that information is readily available there
- this is also why the static storage variable addresses are handled during the examine stage as that information is available only when the executable is built and linked. so combine.py shows up at both the stages as the code to fill in the offsets/addresses is largely the same
- in the PIN tool, there are two call event instrumentations - one at RTN level, one at INS level. the reason for this is that the parts which stay common for all routine calls (like updating the stack) are kept at RTN level, whereas things are different with each call (like the CALLER info) is collected at the INS level.
******************************************************************************************************************

******************************************************************************************************************
Quick file introductions:
0. dependencies.p: contains 3 lists:
		- dependencies
			- for each .c file: contains the included directories containing the included header files
			- for each .a and .so: contains the .o files that make it up
		- sourcefile: holds the .c file for each .o
		- objectfile: holds the .o file for each .c
1. A_clang.xml: information parsed using clang, kept in XML format
2. A.calls.temp: information about functions calls
	- Header: FILENAME	LINENUM	FUNCNAME	CALLNODEID
	- for each function call in A.c it keeps
		- the filename (the call maybe inside some included header file)
		- the start line number
		- the function name
		- the clang nodeid for that function call
3. A.calls.tokens: information about functions calls
	- Header: FILENAME	LINENUM	FUNCNAME	CALLNODEID	CALLEXPR
	- adds the source call expression to the call nodes in A.calls.temp (Callexpr might look like addonemore(2\*p))
	- for function calls arising from macro expansions, it contains the expression pre-expansion i.e. as it will be found in the source code
	- used for linking call expressions at runtime to the source code, using source location information
4. A.funcargs: information about functions signatures
	- Header: FILENAME	FUNCNODEID	FUNCNAME	NARGS	ARGTYPE*	RETTYPE
	- for each function definition in A.c it keeps
		- the filename (the definition maybe inside some included header file)
		- clang nodeid for definition
		- function name
		- number of arguments
		- tab separated list of argument types (eg: FILE \*restrict<tab>const char \*restrict<tab>int)
		- return type
	- used for tracing values of function arguments and returns at runtime
5. A_dd.xml: the dwarfdump info section from A.o
	- for each symbol (variable or function) in A.c
		- contains static source information like its type, line number
		- contains static compile information like its size
		- most importantly:
			- for each local variable contains offset from callsite stack pointer ie 16 + offset from RBP of function containing the variable
			- ^ this is valid offset in .o, .so, .a, executable
			- for each global variable contains offset from image load address for each containing image
			- ^ this is only valid for .so and executable (basically things that generate their independent images)
	- the dwarfdump for .a and .so is effectively just the concatenation of the dump of the contained .o files
	- the information is represented in XML format
	- essentially holds all the object code information
6. A.offset: local (automatic storage) variable RBP offset information
	- Header: FILENAME	FUNCTION	OFFSET	VARNAME	VARID	VARTYPE	VARSIZE	PARENTID
	- for each local symbol in A.c it keeps
		- the filename (the definition maybe inside some included header file)
		- containing function
		- offset from RBP
		- variable name
		- clang nodeid of variable
		- variable type
		- variable size
		- parent id: id of the containing structure/class if variable is a part of structure/class
	- used for identifying local variables at runtime
7. A_comb.xml: XML generated by combining clang and dwarfdump information
	- mangled names for functions are added
	- size of variables are filled
	- offsets (from RBP or image load address) are patched in
	- essentially holds interlinked information from static source code and static object code analysis
8. image.address: static storage variable image load offset information
	- Header: ADDRESS	VARNAME	VARID	VARTYPE	VARSIZE	PARENTID	VARCLASS	[VARCONTAINER]
	- for each static storage symbol in an image it keeps
		- offset from image load address
		- variable name
		- clang nodeid of variable
		- variable type
		- variable size
		- parent id: id of the containing structure/class if variable is a part of structure/class
		- variable class: GLOBAL, FUNCSTATIC, STRUCTSTATIC, CLASSSTATIC
		- variable container: the containing function, structure or class if variable is static local as FUNCSTATIC, STRUCTSTATIC or CLASSSTATIC
	- used for identifying static storage variables at runtime
9. final_idmap.p: stored info from header deduplication stage
	- for all the nodes deleted as duplicates, contains the map from deleted node id to original node id
	- used for correcting files that might contain the nodeids from the deleted nodes
******************************************************************************************************************





