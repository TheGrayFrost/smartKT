******************************************************************************************************************
## Run instructions:
1. run `python initialize.py /path/to/project` for static analysis part (Requires clang installed)
(eg: `python initialize.py testsuite/extern` or `python initialize.py projects/libpng`)
This command
- builds the project
- gets all static information corresponding to C/C++ files in outputs/projectname/
- needs to be run only once for any project
2. create runinfo.json in format specified in `sample_runs.json` containing info regarding the test executables, comment analysis and version control stats.
3. run `python examine.py /path/to/runinfo.json` for the analysis (Requires PIN tool)
(eg: `python examine.py testsuite/extern/runs_extern.json` or `python examine.py sample_runs.json`)
This command
- runs the executables with given inputs and flags (runs it specified number of times)
- gets all dynamic information for all the runs in outputs/projectname/exe_exename/ for each executable
- collects comment information in outputs/projectname/final_comments.xml
******************************************************************************************************************

******************************************************************************************************************
## PROJECT FORMAT

Our tool expects projects to:
	- be C/C++ based
	- use CMake for project build
	- work on Unix-based OSes
	- have verbose makefiles
	- contain test programs that create executables we may examine


### Sidenote: What is CMake?
- CMake is a makefile generator. It takes care of your project build process.
- Basically, it will generate makefiles tailored to the system on which the project is being built.
- So, it will take care of the differences based on the OS. eg: in Windows, .so files are called .dll, options are passed like /a intead of -a
- It will do other things like detect the C++ compiler you are saying eg: maybe the system has clang C compiler instead of gcc


### CMAKE BUILD PROCESS

Basic idea of the CMake build process:
1. You have the source C code
2. You convert each C file to a .o file using `gcc -c`. This .o is called a relocatable object file
3. You can combine a few related object files into two forms of collections: archives(.a) and shared object/shared library (.so)
4. Archives and Shared Objects are basically the .o files written one after the other, combined into one file
5. To create an executable, you take a bunch of .o files (.a and .so are also collections of .o files only as mentioned earlier), and you link them together. This is done using by passing it the object files to gcc.
6. The difference between .a and .so files is that: 
	- .a gets linked statically ie its code gets written into the final executable directly
	- .so gets linked dynamically ie its code is loaded at runtime when executable calls functions from it. Its code is also shared as in multiple executables will use the same copy of the .so
7. Usually, large projects have this structure:
	- take lots and lots of small .c files
	- convert each to .o
	- join all of them into a very large .so file
	- create small executables from some file that contains a main() function
	- that executable links against the large .so, calls functions from that
******************************************************************************************************************


******************************************************************************************************************
## Tool Workflow:

### Imp note on file extensions:
- all extensions are declared in initialize.py/examine.py
- new files containing information about the .c or corresponding .o are generated by parsers in parsers/ folder
- the extensions for the files to generate are passed to the parsers by initialize.py and examine.py
- this approach allows us to modify filenames by making changes only in initialize/examine

1. initialize.py: takes the project as input
	- init(): 
		- uses CMake to generate makefiles
		- then builds the project by running `make`
		- the make command is run in verbose mode, and the commands run by make are collected in make_log.txt
		- creates the folder outputs/projectname
		- moves make_log.txt to this folder
	- generate_static_info():
		- runs parsers/project_parser.py on make_log.txt
		- that generate a dependencies.p (pickle file) that contains file dependency relationships (explained later)
		- for each C/C++ file, say projects/exp/src/A.c, in dependencies.p, we know that a .o will be generated corr. to it. We
			- run clang on A.c to generate A.ast
			- run clangtools
				- parsers/ast2xml: generates A_clang.xml & A.calls.temp from A.ast
				- parsers/calls: generates A.calls.tokens from A.calls.temp
				- parsers/funcs.py: generates A.funcargs from A_clang.xml
			- copy these 3 files to the folder location: outputs/exp/src/A.c/
			- run parsers/dwxml.py on A.o to generate A_dd.xml in outputs/exp/src/
			- run parsers/ddx.py with OFFSET flag
				- that combines only the local variables present in A.c from A_clang.xml and A_dd.xml
				- creates A_comb.xml and A.offset in outputs/exp/src/A.c/
			Note: All these files' purposes are explained in File Introductions section

2. parsers:
	A. project_parser.py:
		- takes each line in make_log.txt
		- takes out the relevant gcc command
		- keeps track of all cd commands to figure out absolute paths of each file
		- figures out which .c files are used to generate which .o
		- figures out which .o files are combined to generate which .a/.so
		- pickles the collected information into dependencies.p (explained later)
	B. dwxml.py: takes the debug info in the .o, converts information into XML (depends on [pyelftools](https://github.com/eliben/pyelftools))
	C. ddx.py:
		- takes in A_dd.xml and A_clang.xml
		- takes in an argument (OFFSET or ADDRESS)
		- if argument is OFFSET, it links all the local variables
		- if argument is ADDRESS, it links all the static storage variables
		- generates corresponding A.offset or A.address based on the flag
		- generates A_comb.xml with offsets/addresses patched in

3. examine.py: takes the runs_info.json
	- creates the folder outputs/projectname/exe_exename
	- generate_static_info():
		- gets the list of all .c files that create the excutable
		- calls combine_all_clang
	- combine_all_clang():
		- for every image contained in the executable (main executable image and all the .so's basically)
			- creates the folder outputs/projectname/exe_exename/imagename
			- for every .c file that makes up that particular image
				- concats the .calls, .funcargs and .offset into final.calls, final.funcargs and final.offset respectively
				- concats their \_clang.xml into image.temp.xml
			- runs dwxml.py on image to generate image_dd.xml
			- run parsers/combine.py with ADDRESS flag
				- that combines only the static storage variables from image.temp.xml and image_dd.xml
				- creates image_comb.xml and image.address (explained later)
			- image.* are kept in outputs/projectname/exe_exename/imagename
		- copies all the image.address files to outputs/projectname/exe_exename/
		- concats all the image_clang.xml into final_clang.xml
	- so now, we have the outputs/projectname/exe_exename/ containing all the static information:
		- image.address for all images creating the executable
		- final_clang.xml
		- final.calls, final.funcargs, final.offset
	- generate_dynamic_info(): runs pin.sh

4. pin.sh:
	- copies executable and test input, if any, into PIN/Work
	- copies the static information collected to PIN/Work/statinfo
	- runs `make executable.dump`, which runs memtracker on executable to generate executable.dump
	- runs pass2.py on executable.dump to generate final_dynamic.xml
	- copies executable.dump and final_dynamic.xml to /projectname/exe_exename/
	
5. memtracker.cpp: * the instrumentation routine name is noted in square brackets [] *
	- Initialization: init()
		- load final.calls, final.funcargs, final.offset into funcCallMap, funcInfoMap, funcLocalMap repectively
		- initializes the function stack record which keeps track of the thread-wise function stack
		- initializes the RBP stack record which keeps track of the thread-wise RBP stack
	- Image Level Instrumentation: ImageLoad()
		- loads image.address information into globalMap
		- adds image load address to the values in image.addres to get runtime address of variables
	- Routine Level Instrumentation: Routine()
		- gets source line information for each function
		- instruments before each function invocation to note the stack change [invP()]
		- instruments before each call to POSIX lock acquisition routines to note the LOCK event [lock_func_bf()]
		- instruments before each call to POSIX lock release routines to note the UNLOCK event [unlock_func()]
	- Instruction Level Instrumentation:
		- gets source line information for each intruction
		- for each intruction whose source is known (basically this excludes the standard header functions)
			- if it is a call instruction [callP()] add instrumentation to
				- collect the runtime value of passed arguments
				- note the CALL event noting down CALLER, current THREAD etc.
				- update the function stack record
			- if it is a return instruction [retP()] add instrumentation to
				- collect the runtime return value of function
				- note the RETURN event noting down current THREAD etc.
				- update the function stack record
			- if it updates RBP (call and return events basically) [updateRBP()], update the RBP stack record
			- if it is a memory access instruction [dataman()] add instrumentation to
				- find if it is a auto or static storage variable
				- locate the variable within the funcLocalMap or globalMap depending on the case
				- generate the corresponding READ or WRITE event
				- note down the locks held by thread while accessing the variable

6. pass2.py:
	- converts executable.dump to XML format
	- accumulates all local variable accesses (read/write) in one function into one XML entry
	- more specifically, if the event sequence is: call A(), read X, read Y, read X, write Y, call B(), return from B(), read X, return from A()
	- ^ this will change into: <call A>, <localaccess X: read 2>, <localaccess Y: read 1 write 1>, <call B>, <ret B> <localaccess X: read 1>, <ret A>
	- ie accesses are accumulated in between special events like function call, return or lock acquisition
	- the access order for static storage variables in preserved

Imp note on tool workflow choices:
- initialize does everything needed to be done for the project to make the further executable analysis faster
- so, all local variable offsets are extracted during initialize stage as that information is readily available there
- this is also why the static storage variable addresses are handled during the examine stage as that information is available only when the executable is built and linked. so combine.py shows up at both the stages as the code to fill in the offsets/addresses is largely the same
- in the PIN tool, there are two call event instrumentations - one at RTN level, one at INS level. the reason for this is that the parts which stay common for all routine calls (like updating the stack) are kept at RTN level, whereas things are different with each call (like the CALLER info) is collected at the INS level.
******************************************************************************************************************

******************************************************************************************************************
Quick file introductions:
0. dependencies.p: contains 3 lists:
		- dependencies
			- for each .c file: contains the included directories containing the included header files
			- for each .a and .so: contains the .o files that make it up
		- sourcefile: holds the .c file for each .o
		- objectfile: holds the .o file for each .c
1. A_clang.xml: information parsed using clang, kept in XML format
2. A.calls: information about functions calls
	- Header: FILENAME	LINENUM	FUNCNAME	CALLNODEID	CALLEXPR
	- for each call expression in A.c it keeps
		- the filename (the call maybe inside some included header file)
		- the start line number
		- the function name
		- the clang nodeid for that function call
		- the call expression (eg: addonemore(2*p))
3. A.funcargs: information about functions signatures
	- Header: FILENAME	FUNCNODEID	FUNCNAME	NARGS	ARGTYPE*	RETTYPE
	- for each function definition in A.c it keeps
		- the filename (the definition maybe inside some included header file)
		- clang nodeid for definition
		- function name
		- number of arguments
		- tab separated list of argument types (eg: FILE *restrict	const char *restrict	int)
		- return type
4. A.dd: the dwarfdump info section from A.o
	- for each symbol (variable or function) in A.c
		- contains static source information like its type, line number
		- contains static compile information like its size
		- most importantly:
			- for each local variable contains offset from callsite stack pointer ie 16 + offset from RBP of function containing the variable
			- ^ this is valid offset in .o, .so, .a, executable
			- for each global variable contains offset from image load address for each containing image
			- ^ this is only valid for .so and executable (basically things that generate their independent images)
	- the dwarfdump for .a and .so is effectively just the concatenation of the dump of the contained .o files
5. A_dd.xml: simply the XML representation of the information in A.dd
6. A.offset: local (automatic storage) variable RBP offset information
	- Header: FILENAME	FUNCTION	OFFSET	VARNAME	VARID	VARTYPE	VARSIZE	PARENTID
	- for each local symbol in A.c it keeps
		- the filename (the definition maybe inside some included header file)
		- containing function
		- offset from RBP
		- variable name
		- clang nodeid of variable
		- variable type
		- variable size
		- parent id: id of the containing structure/class if variable is a part of structure/class
7. A_comb.xml: XML generated by combining clang and dwarfdump information
	- mangled names for functions are added
	- size of variables are filled
	- offsets (from RBP or image load address) are patched in
8. image.address: static storage variable image load offset information
	- Header: ADDRESS	VARNAME	VARID	VARTYPE	VARSIZE	PARENTID	VARCLASS	[VARCONTAINER]
	- for each static storage symbol in an image it keeps
		- offset from image load address
		- variable name
		- clang nodeid of variable
		- variable type
		- variable size
		- parent id: id of the containing structure/class if variable is a part of structure/class
		- variable class: GLOBAL, FUNCSTATIC, STRUCTSTATIC, CLASSSTATIC
		- variable container: the containing function, structure or class if variable is static local as FUNCSTATIC, STRUCTSTATIC or CLASSSTATIC
******************************************************************************************************************





